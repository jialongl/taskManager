\documentclass[12pt, a4paper]{article}
\usepackage{indentfirst}
\usepackage{graphicx}
\graphicspath{{/home/jialongl/Documents/sem3/se/proposal/}{/home/jialongl/Documents/sem3/se/finalprojScreenshots/}}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    urlcolor=blue
}
\usepackage{verbatim}
\usepackage{fullpage}

\usepackage{color}
\definecolor{light-gray}{gray}{0.80}

\usepackage{listings}
\lstset{breaklines=true,
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\scriptsize\sffamily\raggedright,
  captionpos=b
}

%\oddsidemargin 0.3in
%\topmargin -0.3in
%\textheight 8.0in

%\usepackage{setspace}
%\onehalfspacing

%\usepackage{palatino}
%\usepackage{avant}

\newcommand{\cmd}[1]{{\bf \texttt{\begin{quote} #1 \end{quote}}}}
\newcommand{\cmdinline}[1]{{\bf \texttt{#1}}}

\begin{document}
\begin{titlepage}
  \centering

  \textsc{\LARGE cs2103 project manual}
  \\[1.5cm]
  \hrule
  \\[0.5cm]
  \Large \bfseries Command line task manager
  \\[0.4cm]
  \hrule
  \\[1.4cm]
  \includegraphics[scale=0.73]{on_cover_page}
  \\[1.1cm]

  \begin{tabular}{c | c | c | c}
    \includegraphics[scale=0.96]{U099121H}&
    \includegraphics[scale=0.72]{U099122U}&
    \includegraphics[scale=0.72]{U099120W}&
    \includegraphics[scale=0.72]{U094837M}\\

    \small{He Haocong} & \small{Liu Jialong} & \small{Wang Xiangyu} & \small{Zhou Biyan}\\
    \small{\texttt{U099121H}} & \small{\texttt{U099122U}} & \small{\texttt{U099120W}} & \small{\texttt{U094837M}}\\
  \end{tabular}

  \vfill
  {\large Group L11\\ \today}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}
%% This is the manual for a command-line utility (referred to as taskManager later in this document) that manages one's to-do's.

%% TaskManager is a multi-platform command-line application. It allows users to type
%% in command to execute various operations. taskManager is designed to help the user to
%% deal with various tasks. One can do “add”, “remove”, “view” and many other operations to deal
%% with the tasks. By typing different commands, the user is allowed to create new and modify
%% existing tasks. In addition to the basic task manager functionalities, taskManager also
%% includes a Text-User-Interface (TUI). The purpose of applying this dual-UI design is mainly for
%% the convenience of different user groups. The TUI is hopefully easier for Windows users who are
%% comfortable with clear and viewing-all user interfaces. While Unix OS users who are more used
%% to typing commands to control the system can achieve the same goal by typing commands to
%% the task manager. 

%% TaskManager has powerful functionalities such as auto-completion and
%% user-define commands. It also supports importing existing to-do lists and exporting to a human-
%% readable file with a nice formatting for printing out.

TaskManager (referred to as taskManager later in this document) is a multi-platform command-line application that manages one's to-do's.

It maintains a list of tasks and provides a rich collection of
commands to manipulate them. It comes with a TaskManager shell (which
features a command-line interface) and an interactive text-based user
interface (TUI). Besides basic task manager functionalities, it
supports command aliasing, piping and start up script.  A decent set
of command aliases are defined in the .tmrc file to enable
intuitive command line task management. Finally, the auto-completion
module adds on to the usability and \cmdinline{import}/\cmdinline{export} commands make sharing and visualizing tasks easy.

\newpage
\section{User Guide}
\subsection{Quick Start}

This section introduces you the minimum amount of commands to get started.

\begin{enumerate}
\item Start taskManager shell:

On Mac OS and GNU Linux (referred to as ``*nix'' later), taskManager can be started from shell by commands: \cmd{\$ cd the/folder/containing/taskManager\\ \$ ./taskManager\footnotemark}

On Microsoft Windows, taskManager can be launched in command prompt as well, or simply by double clicking ``taskManager.exe''.

Once taskManager is launched, you will see a prompt like \cmdinline{"> \_"}, and you will start typing commands!

\footnotetext{ *nix version can be run at any directory after installing taskManager -- \cmdinline{"make install"}. See details in section \cmdinline{"Compilation and Installation".}}

\item Add some tasks:\cmd{\begin{tabbing}
    \$ ./taskManager\\
    > \ \=add "Sample task 1"\\
    > \ \>add "Sample task 2"\\
    TaskManager: This task is highly similiar to some existing task:\\
    \>1 \hspace{0.3in}Sample task 1\\
  Do you really want to add it? \textcolor{blue}{y}
  \end{tabbing}
}
To add a task, simply use \texttt{add} command followed by the description of the task in a pair of quotation marks.

\emph{If no error messages are shown, the task is successfully added.}
TaskManager may prompt for confirmation if the task to be added is highly similar to some existing task(s) to help prevent people forget adding tasks, which is the case in the example above.

\item List the existing tasks: 
\cmd{\begin{tabbing}
    > \ ls\\
    1 \hspace{0.3in} \= Sample task 1\\
    2 \>Sample task 2
  \end{tabbing}
}
To see the existing tasks, use \cmdinline{ls} command. By default, the taskManager shows the serial numbers and the descriptions of the tasks.

\item Mark a task as finished:
\cmd{
  \begin{tabbing}
    > \ finish 2\\
    > \ ls\\
    1   \hspace{0.3in} \=Sample task 1\\
    2 f \>Sample task 2
  \end{tabbing}
}
To finish an existing task, use \cmdinline{finish} command followed by the serial number of the task to finish. 
Notice that for finished task, an `f' is shown between serial number and task description.

\item Remove task(s): \cmd{\begin{tabbing}
    > \ ls\\
    1 \hspace{0.3in} \= Sample task 1\\
    2 f \>Sample task 2\\
    > \ rm 1\\
    TaskManager: Do you really want to remove this task permanently? \textcolor{blue}{y}\\
    > \ ls\\
    2 f \>Sample task 2
  \end{tabbing}
}

To remove an existing task, use \cmdinline{rm} command followed by the serial number of the task to remove. TaskManager will prompt for confirmation when removing tasks.

\item Exit from taskManager:
\cmd{> \ exit}

To quit from taskManager, use \cmdinline{exit} command. 
All changes to the existing tasks will be automatically saved.
\end{enumerate}

\subsection{More commands}
\subsubsection{read, import and export}

TaskManager stores the tasks in an XML file which is by default \cmdinline{$\sim$/record.xml} on *nix, and \cmdinline{\%USERPROFILE\%\textbackslash record.xml} on Windows.

TaskManager also supports importing/exporting the existing tasks from/to XML and HTML files. This is done by \cmdinline{read}, \cmdinline{import} and \cmdinline{export} commands.

\begin{enumerate}
\item [ \cmdinline{read} ] reads an XML file, list all the tasks it contains without affecting the current task list.

This is helpful when you only want to peek the content of an xml file without really importing it.
\cmd{
\begin{tabbing}
  > \ ls\\
    1 \hspace{0.3in}\=  Sample task 2\\
    > \ read midterms.xml\footnotemark \\
    1 f \>CS2103 midTerm Sep 29 06:30 - 07:30 pm MPSH 1B\\
    2 f \>CS3230 midTerm Oct 15 06:00 pm\\
    3 f \>CS3241 midTerm Oct 07 lecture\\
    4 f \>CS3244 midTerm Oct 04 lecture\\
    5 f \>ST2132 midTerm Oct 08 LT33 12:15 - 1:30 pm\\
    > \ ls\\
    1 \>Sample task 2
\end{tabbing}
}

\footnotetext{ The file name is not quoted. If the file name contains space, please quote it with a pair of quotation marks.}

\item [ \cmdinline{import} ] is similar to \cmdinline{read} command. It reads the content of the XML file and appends all the tasks in it to current task list.
\cmd{
\begin{tabbing}
  > \ ls\\
    1  \hspace{0.3in}\=Sample task 2\\
    > \ import mytasks.xml\\
    1 \>Sample task 2 \footnotemark\\
    2 f \>CS2103 midTerm Sep 29 06:30 - 07:30 pm MPSH 1B\\
    3 f \>CS3230 midTerm Oct 15 06:00 pm\\
    4 f \>CS3241 midTerm Oct 07 lecture\\
    5 f \>CS3244 midTerm Oct 04 lecture\\
    6 f \>ST2132 midTerm Oct 08 LT33 12:15 - 1:30 pm
\end{tabbing}
}

\footnotetext{ Task 1 is still in task list. Importing tasks will not erase existing tasks.}

\item [ \cmdinline{export} ] exports the current task list to an XML or HTML file.
\cmd{
  \begin{tabbing}
    > \ export sampletasks.xml\footnotemark\\
    > \ \=exit\\
    \$ \>cat sampletasks.xml\\
    \>\+<taskList>\\
    <task>\\
    <serialNumber> 1 </serialNumber>\\
    <deadline> 1288473083 </deadline>\\
    <priority> 0 </priority>\\
    <description> Sample task 2 </description>\\
    <group> default </group>\\
    <isFinished> 0 </isFinished>\\
    </task>\\
    </taskList>
  \end{tabbing}
}

\footnotetext{ Currently \cmdinline{export} does not support environmental variables in path. i.e. \cmdinline{export $\sim$/abc.xml} will not export the file to user's home directory \cmdinline{/home/username/}.}
 
\cmdinline{export} can also be used to generate an HTML file which is more visually pleasant in your favourate browser.
\cmd{> \ export -html sampletasks.html\footnotemark\\
  > \ exit}
\footnotetext{ If the name of the HTML file to export is not specified, the default file name \cmdinline{"record.html"} is used.}

\newpage
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.73, viewport=80 0 600 380]{exporthtml}
  \caption{tasks exported as webpage \footnotemark}
\end{figure}
\end{enumerate}
\footnotetext{ Page may not render correctly in IE 6 or its earlier versions.}

\subsubsection{task}
\noindent \cmd{
  \begin{tabbing}
    > \=task 1 \+\\
    Number: \ \= 1  \ \ \= Deadline: \=Sun Oct 31 05:11:23 2010\\
    Priority:\>0 \> Status:\>Doing\\
    Group:\> default\\
    Details:\\
    \ \ Sample task 2 \footnotemark
  \end{tabbing}
}
\footnotetext{ Adding tasks with detailed information is covered in section 2.3.1. In this example, default values are shown.}
To show detail information of a task, use \cmdinline{task} command followed by serial number of the task.

\subsubsection{pri}
\noindent \cmd{
  \begin{tabbing}
    > \  pri 1 10\\
    > \ \=task 1 \+\\
    Number: \ \= 1 \ \ \= Deadline: \= Sun Oct 31 05:11:23 2010\\
    Priority:\>10 \> Status:\>Doing\\
    Group: \> default\\
    Details:\\
    \ \ Sample task 2
  \end{tabbing}
}

To change the priority of a task, use \cmdinline{pri} command followed by the serial number of a task and its new priority.
Priority is typically a number between -20 and 20. By default, the priority of a newly added task is 0.

\subsubsection{edit}
\noindent \cmd{
  \begin{tabbing}
    > \ edit 1 -d "Sample task 3" -p 12 -t 1d\footnotemark \ -g SampleGroup -f yes\\
    > \ \=task 1 \+\\
     Number: \ \= 1 \ \ \= Deadline: \=Mon Nov  1 05:47:59 2010\\
     Priority:\>12 \> Status:\>Finished\\
     Group: \> SampleGroup\\
     Details:\\
     \ \ Sample task 3
  \end{tabbing}
}

To edit a task, \cmdinline{edit} command which has the form: \cmdinline{edit taskSerialNumber -d newDescription -p newPriority -t newDeadline -g newGroup -f finished\_or\_not}. Only \cmdinline{taskSerialNumber} is compulsory. Besides, to finish a task, \cmdinline{finish 1} is equivalent to \cmdinline{edit 1 -f yes}.

\footnotetext{ -t 1d means setting the deadline to be 1 day later. Time formats that taskManager accept are discussed in section 2.3.1.}

\subsubsection{undo and redo}
\noindent \cmd{> \ undo}
would undo the last command. Note that it has no effect on commands like \cmdinline{ls}, \cmdinline{export}, \cmdinline{tui} and \cmdinline{undo}.
\cmd{> \ redo}
re-does the last undo. It can be executed util all the undo's are re-done.

\subsection{Using Options}

Like \cmdinline{edit}, some of the commands come with options to support more functionality.
In this section they are introduced in great detail.

%\cmdinline{export} not support the task-selective options \cmdinline{-g -k -f}.
%Executing these commands on a selected task set can be done with command piping, which is discussed in section 2.5.1.

\subsubsection{add}
\cmdinline{add} has three flags: \cmdinline{-t} to specify deadline, \cmdinline{-p} to set priority and \cmdinline{-g} to put the group name for a task.
\begin{enumerate}
\item [ \cmdinline{-t} ] adds a task with a deadline: \cmd{> \ add "74 hours from now" -t 3d2h\\
  > \ add "Tomorrow 2359" -t b2d\\
  > \ add "due at Jan 2, 1970 00:00 UTC" -t 86400
}
TaskManager support 3 types of time format:

\begin{enumerate}
\item[ \cmdinline{"plus" format} ]
  ``Plus'' format specifies the how much time left for the task, and it has form \cmdinline{?w?d?h?m}\footnotemark, where each question mark stands for a number (not a digit).\\
  For example, 3d2h means the task will due after 3 days 2 hours the moment the command is executed -- you have 3 days and 2 hours to finish it.

\footnotetext{ At least one of letters w/d/h/m should be specified.}

\item[ \cmdinline{"by" format} ]
  ``By'' format has a similar form of ``plus'' format. It is in the form of \cmdinline{b?w?d?h?m}\footnotemark, where each question mark stands for a number (not a digit). For example:
\footnotetext{ At least one of letters w/d/h/m should be specified.}

\begin{tabular}{ r | l }
  \cmdinline{b0d22h} & by 10:00pm today.\\
  \cmdinline{b2d} & by 23:59 tomorrow.\\
  \cmdinline{b1w} & by the end of this week. i.e. 23:59 of the Saturday\footnotemark of this week. \\
  \cmdinline{b0w5d} & by 23:59 on Friday of this week.\\
  \cmdinline{b2w3d8h} & by 8:00am on the Wednesday of the next next week.\\
\end{tabular}

\footnotetext{ Sunday is the first day of a week.}

\item[ \cmdinline{Unix timestamp} ]
``Unix timestamp'' means the number of seconds elapsed since Jan 1, 1970 00:00:00. It is not recommended for users, but rather used as a lower-order procedure for developers.
\end{enumerate}

\item[ \cmdinline{-p} ] adds a task with a priority: \cmd{> \ add "some important task" -p 20}
\item[ \cmdinline{-g} ] specifies a group for a task: \cmd{> \ add "the task with group"\footnotemark \  -g SampleGroup}
\end{enumerate}

\footnotetext{ If group name contains spaces, use a pair of quotation marks to quote it.}

\emph{Options are not compulsory. Different options can be used together.} For example: \cmd{> \ add "CS2103 final exam" -p 10 -g "finals" -t b3w2d} would add a task ``CS2103 final exam'' which has a priority of 10, belongs to group ``finals'' and is held on the Tuesday 3 weeks from now.

\subsubsection{ls}
\cmdinline{ls} has four flags: \cmdinline{-s} to sort tasks, \cmdinline{-k} to search tasks, \cmdinline{-f} to view only (un)finished tasks and \cmdinline{-g} to filter tasks by group name.
\begin{enumerate}
\item[ \cmdinline{-s} ] sorts the existing tasks: \cmd{> \ ls -s "deadline priority"}

A more general format is: \cmdinline{ls -s "keyword1 keyword2" \ldots}

The listed tasks will be sorted by keyword1 and then keyword2 \ldots
    
Available columns are: deadline, priority and serialnumber. Prefix of a keyword is also acceptable. e.g. \cmdinline{ls -s "p"} will sort the tasks by their priorities.

Examples: \cmd{
\begin{tabbing}
  > \ ls -s "p d" \+\\
  1 \hspace{0.3in}\= task 1 highest priorty. \ \=  3  Sun Oct 31 06:49:09 2010\\
  2 \> task 2 high priority. \> 2  Mon Nov  1 06:54:42 2010\\
  3 \> task 3 default priority. \> 0   Tue Nov  2 06:54:37 2010
\end{tabbing}
}
\item [ \cmdinline{-k} ] filters tasks with a keyword\footnotemark \ where \cmdinline{?} means any single character, \cmdinline{*} means a string of any length (including 0 length).
\footnotetext{ keyword is case insensitive.}

Take command \cmdinline{ls -k *Sam?le*task} as an example, \cmdinline{"This is a sample with an important task"} will match \cmdinline{*Sam?le*task} as the first \cmdinline{*} matches \cmdinline{"This is a "}, \cmdinline{?} matches \cmdinline{`p'} and the second \cmdinline{*} matches \cmdinline{" with an important "}.

\cmdinline{"samqleTask"} will also match \cmdinline{*sam?le*task} as both \cmdinline{*} maps empty string and \cmdinline{?} to be \cmdinline{`q'}.

\item[ \cmdinline{-f} ] shows finished/unfinished tasks:

  \cmdinline{ls -f yes} shows only finished tasks.\\
  \cmdinline{ls -f no} shows only unfinished tasks.

\item[ \cmdinline{-g} ] shows tasks of a specific group: \cmdinline{ls -g SampleTask} makes tasks only from SampleTask group shown.
\end{enumerate}

{\bf  \textcolor{red}{Important}}:
\begin{quote}
As said, different options can be used together when issuing commands.
When more then one restrictive options are present, \emph{conjuction} of these restrictions are used. e.g. \cmd{ls -g SampleTask -f y} will show tasks that are finished AND from ``SampleTask'' group. 
\end{quote}

\subsubsection{rm}
\cmdinline{rm} has basically two usages: remove tasks by a group name or serial number.

Use \cmdinline{-g} option to remove a group of tasks: \cmdinline{rm -g SampleTask} removes the entire SampleTask group.

\cmdinline{rm} can be used remove several tasks once as well. e.g. \cmdinline{rm 1 2 3} removes tasks 1, 2 and 3.

%% \subsubsection{edit}
%% This is discussed in section 2.2.4.

%% \subsubsection{export}
%% This is discussed in section 2.2.1.


\subsection{Getting inTUItive -- The Text User Interface}
The text-based user interface (referred to as TUI later) makes interaction more intuitive by visualizing the deadlines, groups and simplifying manipulation from issuing commands to moving cursors and pressing keys.

\\TUI can be launched using command \cmdinline{tui} in command-line mode:

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.73]{tui-launched-mac}
  \caption{The first screen of TUI}
\end{figure}

As seen, the tasks are grouped according to deadlines. If a task's deadline is ``Anytime'', it means the task has no specific deadline -- you can finish it at ease.

Besides, TUI provides some features that are not available in the command line mode:\begin{enumerate}
\item auto-completion

  TUI helps you complete words (including built-in commands and words you have entered) using \cmdinline{TAB} key. For example, after you typed \cmdinline{"un"}, the word \cmdinline{"do"} will appear right after \cmdinline{"un"} in cyan, and now you can complete the word \cmdinline{"undo"} if you press \cmdinline{TAB}.
\item summary of tasks in a calendar

  Press \cmdinline{c} in TUI, a small calendar would appear at the bottom right corner. The dates that has tasks due have a highlighted background. You can navigate dates using arrow keys to see what exactly are the tasks due on that date.
\item incremental search of tasks by keyword.

  Press \cmdinline{s} in TUI to start incremental search -- tasks become fewer and fewer as you type. Press \cmdinline{ENTER} to end searching and do whatever thing you like on the tasks!
\end{enumerate}

This is a summary of the key bindings:\\

\begin{tabular}{c | c}
  \cmdinline{SPACE} or \cmdinline{ENTER} & show details of the selected task\\
  \cmdinline{$\downarrow$} or \cmdinline{j} & select the task below\\
  \cmdinline{$\uparrow$} or \cmdinline{k} & select the task above\\
  \cmdinline{g} & select the first task \\
  \cmdinline{G} & select the last task \\
  \cmdinline{number selectionKey}\footnotemark & select \cmdinline{number} tasks above/below\\
  \cmdinline{p} & previous page/page up\\
  \cmdinline{n} & next page/page down\\
  \cmdinline{u} & undo\\
  \cmdinline{R} & redo\\
  \cmdinline{c} & show the small calendar\\
  \cmdinline{C} & issue a command without leaving TUI\\
  \cmdinline{a} & add a task\\
  \cmdinline{e} & edit a task\\
  \cmdinline{d} & remove a task\\
  \cmdinline{f} & finish a task\\
  \cmdinline{s} & search tasks by keywords\\
\end{tabular}
\footnotetext{ It means pressing a number key and then press $\uparrow$/$\downarrow$/\cmdinline{j}/\cmdinline{k} key.}

You can always press \cmdinline{H} to read the key bindings.

\subsection{Advanced Usages}
\subsubsection{command piping}
\noindent \cmd{> \ ls \textbar \  rm}
TaskManager supports command piping for most commands though it is a bit different from traditional Unix pipe.
Piping means if one command selects some tasks, then the selected tasks will be passed to the next command as input. The tasks after the last command will be shown as output.
Piping in taskManager is done with symbol \cmdinline{\textbar}. When a pipe signs appear in a command, the broken-up commands (separated by pipes) are executed one by one from left to right. For example:

\begin{enumerate}
\item finish all tasks:  \cmd{> \ ls \textbar \  finish}
\item remove all finished tasks:  \cmd{> \ ls -f yes \textbar \  rm}
\item import from a file and replace current task list:  \cmd{> \ ls \textbar \  rm \textbar \  import newTasks.xml}
\item import all CS2103 group tasks from a file:  \cmd{> \ read newTasks.xml \textbar \  ls -g CS2103 \textbar \  add}
\item export all CS2103 related tasks to a html file: \cmd{> \ ls -k *CS2103* \textbar \  export -html cs2103tasks.html}
\item show details of CS2103 tasks, sort by priority: \cmd{> \ ls -g CS2103 \textbar \  sort "pri" \textbar \  task}
\end{enumerate}

\subsubsection{command mapping}
\noindent \cmd{> \ map "ls" "ls -f no"}
TaskManager supports custom command mapping/aliasing so you can alias the taskManager commands to the format you are more comfortable with.

General format of \cmdinline{map} is: \cmdinline{map "new command" "original command"}

A simple mapping is like the previous example, which maps \cmdinline{ls} to \cmdinline{ls -f no}, which effectively hides finished tasks when doing \cmdinline{ls}.
To retain the original \cmdinline{ls} command, use \cmdinline{\ls}. The command that \cmdinline{ls} maps to will not be executed then.

When several \cmdinline{map} commands are executed in sequence : \cmd{> \ map "lsa" "ls"\\
  > \ map "ls" "ls -f no"}
Then \cmdinline{ls} will show the unfinished tasks only, while \cmdinline{lsa} lists all the tasks.

The order of mapping matters as commands are executed one by one. Thus reversing the order of \cmdinline{map} commands MIGHT NOT work.

More complex mapping makes use of symbol \cmdinline{\$}. There are two kinds of \cmdinline{\$} symbols:
\begin{quote}
\cmdinline{\$0} matches all characters from the current position.\\
\cmdinline{\$1}, \cmdinline{\$2}, \cmdinline{\$3} \ldots matches one token (i.e. a word or several words .
\end{quote} Examples:
\begin{enumerate}
\item \cmd{> \ map "tomorrow \$1" "add \$1 -t 1d"\\
  > \ tomorrow "Finish user guide"}    
The latter command will be parsed as \cmdinline{add "Finish user guide" -t 1d}, and a new task ``Finish user guide'' will be added with the deadline of 24 hours.

\item \cmd{> \ map "do \$1 at \$2" "add \$1 -t \$2"\\
  > \ do "Laundry" at 4h}
The latter command will be parsed as \cmdinline{add "Laundry" -t 4h}, and a new task called ``Laundry'' will be added with the deadline of 4hours.

\item \cmd{> \ map "ls \$0" "ls -f no \$0"\\
  > \ ls\\
  > \ ls -g cs2103}
The second command will be parsed as \cmdinline{ls -f no}, and will list out all unfinished tasks.
The third command will be parsed as \cmdinline{ls -f no -g cs2103}, and will list out all unfinished cs2103 tasks.
\end{enumerate}

{\bf \textcolor{red}{Important:}}
%\begin{quote}
TUI uses \cmdinline{ls} to retrieve tasks. Mapping \cmdinline{ls} to something else will affect behaviour of TUI, which may or may not be the case you want.
%\end{quote}

\subsubsection{taskManager script}

Task manager commands can be saved in a text file and be executed using run command. \cmd{
\begin{tabbing}
  \$ cat tmscript\\
  ls\\
  map "ls" "ls -f no"\\
  ls\\
  \$ ./taskManager\\
  Task Manager V 0.2\\
  type " exit" to quit, "help" for more instructions\\
  ==================================================\\
  > \ run tmscript\\
  1 f \hspace{0.16in}\=Sample task 1. This also has high priorty\\
  2 \> Sample task 2. This has high priority\\
  3 \> Sample task 3. This is the latest\\
  \\2 \> Sample task 2. This has high priority\\
  3 \> Sample task 3. This is the latest
\end{tabbing}
}

The first 3 tasks are the result of the first \cmdinline{ls} in the script. The last 2 tasks are the result of the second \cmdinline{ls} in the script. Because \cmdinline{ls} is mapped to \cmdinline{ls -f no}, finished tasks are not shown by the second \cmdinline{ls}.

% TaskManager scripts are plain text files. ".txt" suffix is omitted here. In windows, suffix is hidden by default. To show it, check corresponding checkbox under Tools -> \ Folder Options in a file browser. Windows may not know how to open file with no suffix.

\subsubsection{startup script}

By default, taskManager executes a special script everytime when it is started. 
This script is \cmdinline{$\sim$/.tmrc} on *nix and \cmdinline{\%USERPROFILE\%\textbackslash tmrc.txt} on Windows.
This file can be editted to include customized settings.\\

Examples:
\begin{enumerate}
\item To switch to the interactive user interface by default, add this line into tmrc: \cmd{tui}
\item To save a backup file when taskManager is started: \cmd{export /tmp/backupTasklist.xml}
\item To show tasks when taskManager is started: \cmd{ls}
\item To remove finished tasks when taskManager is started: \cmd{ls -f yes \textbar \  rm}
\item To run a script with all self-defined mappings when taskManager is started:  \cmd{run /home/myusername/mymappings}
\end{enumerate}

\subsubsection{talk to taskManager}

For all inputs that cannot be recognized by taskManager as a command, it will be treated as natural language sentense. 
TaskManager will try its best to recognize it and give correct response. For example: \cmd{> \ what do I do today?} will list all the tasks due today.

\subsection{Compilation and Installation}
This section discusses compilation and installation of taskManager.
One thing to note is that the TUI is build by default, which requires PDcurses library.
It is free and can be downloaded here:
\url{http://sourceforge.net/projects/pdcurses/files/}.

Unix-like Operating Systems are likely to have curses (its cross-platform version is PDcurses) library installed already.
For Windows' users convenience, the necessary library files for compilation are included in the zip.

\subsubsection{Microsoft Windows}
On Windows, taskManager can be built with Visual Studio 2008\textsuperscript{\textregistered} \footnotemark \ in the following steps:

\begin{enumerate}
\item Start Visual Studio with ``C++ Development Settings''.
\item Create an \emph{empty win32 console project} called ``taskManager''.
\item Drag all the .h and .cpp files (including those in the subdirectories) into the solution folder. Files should be automatically categorized into header files and source files.
\item Press \cmdinline{Alt + F7} to edit the project properties. Under \cmdinline{"Configuration Properties" => "General"}, set \cmdinline{"Character Set"} to be \cmdinline{"Use Multi-Byte Character Set"}; Under \cmdinline{"Linker" => "Input"}, add pdcurses.lib to \cmdinline{"Additional Dependencies"} and add the folder containing \cmdinline{pdcurses.lib} to \cmdinline{"Additional Library Directories"}.
\item Copy \cmdinline{pdcurses.dll} to \cmdinline{\%WINDIR\%\textbackslash system32\textbackslash} or the directory your executable will be generated (which would probably be ``Debug'' folder).
\item Build the solution.
\item Copy \cmdinline{tmrc} to your home directory (e.g. \cmdinline{C:\textbackslash Documents and Settings\textbackslash John Doe\textbackslash} on Windows XP) and rename it to \cmdinline{tmrc.txt} in order to use the commands we pre-customized. This step is optional.
\end{enumerate}

\footnotetext{ Menu names mentioned below may vary among different versions of Visual Studio.}

\subsubsection{Unix-like Operating Systems}

On Unix-like operating systems such as GNU Linux and Mac OS X: start a shell; unzip the zip archive; change directory properly and type: \cmd{\$ make\\
  \$ sudo make install}

``make install'' is optional. It just makes taskManager available system wide by copying the executable and man page to cooresponding directories.

Another option is to copy the \cmdinline{tmrc} to your home directory and rename it to \cmdinline{.tmrc} in order to use the commands we pre-customized.

The curses library should ship with most Linux distributions and Mac OS. If not, it can be installed with the package manager (\cmdinline{apt-get}, \cmdinline{yum}, \cmdinline{pacman} on various Linux distributions and \cmdinline{port} on Mac).

\newpage
\section{Developer Guide}
This part of the manual is mainly meant for developers. Users who are interested in finding out
the actual structure behind are also welcome to read this part.

\subsection{Development Process}
\subsubsection{Overview}
We strictly  followed a top-down  approach designing the  software. As
for the software development life  cycle (SDLC), our team is following
the  iterative approach so  that every  version of  our software  is a
complete and working product that  satisfies our target users. In each
iteration, we  are following the  waterfall approach to save  time and
energy.

\subsubsection{Domain Analysis}
\begin{enumerate} 
\item Requirement Study

This project aims to build up a task manager program that helps user to manager  his/her
to-do's. This program should provide the user with a CLI (command line interface), which means a
user is able to type \mbox{\cmdinline{add "write developer's guide" -t 1d}} at the prompt to add a new task ``write developer's guide'' which has a deadline of 1 day.

We did some surveys to find out what are the common features that existing products have -- adding/displaying/editting/removing tasks, setting priorities, search tasks by keywords\ldots
We then brainstormed together to come up with other features that could possibly fill in the blanks of existing products and provide users with software of better quality and user experience, for example System alert/notification, integration with system calendar (though they are not implemented), natural commands and auto-completion of commands\ldots

As the product should cater Windows users, we have also decided to make a TUI (text user interface) in order to create a
more user friendly environment after conducting interviews with typical Windows users. (user guide for TUI is given in section 2.4)
%The TUI supports keyboard operations like arrow keys and screen scrolling. An example is given as below in Figure 1.

\item OO Domain Model

A condensed object-oriented domain model is given in Figure 3. This model is an overview of the
problem domain and ignores most of the details. Basically, the problem is modeled as a user
interacting with a task manager that manages his/her tasks. More detailed descriptions about sub-problems like
how commands are parsed, how tasks are modified and stored, how messages are shown to the screen, as discussed in the following.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{a-condensed-OO-domain-model}
  \caption{A condensed OO domain model}
\end{figure}
\end{enumerate}

\subsubsection{Design}
We chose a multi-tier architecture, in fact the most widely used
three-tier architecture to implement the program. Figure 4 shows the diagram of
the architecture. The user can interact with the software through either CLI or TUI.
The user interfaces will pass whatever command it receives from the user to the Logic.
The Logic of the program will then perform its tasks accordingly and manipulate the storage
files which store all the user data.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{three-tier-architecture}
  \caption{Three-tier Architecture}
\end{figure}

\subsubsection{Implementation}
\begin{enumerate}
\item  Overview of the taskManager workflow:
\begin{enumerate}
\item The program starts with a \cmdinline{shell}.
\item \cmdinline{Shell} asks \cmdinline{IO Module} to get user input.
\item \cmdinline{IO Module} requests the \cmdinline{Parser} to parse the text input to a \cmdinline{CommandList} object for it. Then \cmdinline{IO Module} returns the \cmdinline{CommandList} to \cmdinline{Shell}.
\item \cmdinline{Shell} calls \cmdinline{MainCommandExecutor} which will execute the command accordingly.
\item The \cmdinline{MainCommandExecutor} returns a \cmdinline{Result} object to the \cmdinline{Shell}.
\item \cmdinline{Shell} requests \cmdinline{IO Module} again to handle screen output using the \cmdinline{Result} object.
\item \cmdinline{IO Module} uses \cmdinline{Parser} to parse the \cmdinline{Result} to a string and print that string.
\end{enumerate}

The flow chart of the above process is given as:
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{class-diagram1}
  \caption{Workflow of taskManager}
\end{figure}

\newpage
\item UI Implementation

We have implemented two user interfaces -- CLI and TUI.
As user interfaces, they basically reads text input (be it a string or a keystroke) from the user and passes it to the \cmdinline{Logic} and receive \cmdinline{Result} objects and print to screen. 

Thus in our implementation, they are both \cmdinline{IO Module}s  -- The CLI is implemented as \cmdinline{Keyboard IO Module} and the TUI is implemented as \cmdinline{PdcIO}. The advantages of this polymorphism are:
\begin{enumerate}
\item the \cmdinline{Logic} does not need to know what is exactly (\cmdinline{Keyboard IO Module} or \cmdinline{PdcIO}) it is talking to it. For example, \cmdinline{Logic} can just call \cmdinline{getCommand()} method and the \cmdinline{Command} will be generated.

\item it will be easy when you want to implement, say a GUI, for taskManager in the future.

\item decreases the level of coupling in the software -- the \cmdinline{Logic} does not need to be aware of each \cmdinline{IO Module}.
\end{enumerate}

%\begin{lstlisting}[float=h,language=C++,caption={A "Hello World" program.},label={code:helloworld},captionpos=b,abovecaptionskip=1em,belowcaptionskip=-2em,columns=flexible,frame=single,linewidth=0.8\linewidth]
\newpage
\begin{center}
  \lstset{
    caption=abstract methods in \cmdinline{TM\_IO\_Module.h} to apply polymorphism,
    basicstyle=\ttfamily\footnotesize\bfseries,
    columns=flexible,
    linewidth=0.9\linewidth,
    abovecaptionskip=0.5em,
    frame=tb
  }
  \begin{lstlisting}
    virtual void showWelcomMessage() {};
    virtual CommandList getCommand() {return vector<Command *>();};
    virtual void showOutput (Result* result) {};
    virtual void handleException(exception_e except) {};
    virtual void confirm(string prompt) {return true;};
    virtual void echo (string s) {};
  \end{lstlisting}
\end{center}


\item Logic Implementation

The Logic part of taskManager is in charge of getting Command

\begin{enumerate}
\item Shell

The \cmdinline{shell} is the controller of the whole Logic. Shell is able to start a loop that in each iteration:
\begin{enumerate}
\item asks \cmdinline{IO Module} for a \cmdinline{CommandList} object. Why a \cmdinline{CommandList} object instead of a \cmdinline{Command} object? It is because a line read by \cmdinline{IO Module} could contain several \cmdinline{Command}s separated by pipes (which are denoted as `\textbar', see section 2.5.1, command piping for details). 
\item calls the \cmdinline{MainCommandExecutor} to handle each \cmdinline{Command} in the \cmdinline{CommandList}. A \cmdinline{Result} object will be returned to the \cmdinline{Shell}.
\item passes the \cmdinline{Result} to \cmdinline{IO Module} and asks it to print things to screen using the \cmdinline{Result}.
\end{enumerate}

We applied the top-down approach when designing this loop so that \cmdinline{Shell} does not need to care about:
\begin{itemize}
\item how \cmdinline{IO Module} generates that \cmdinline{CommandList};
\item how commands are executed -- it just calls \cmdinline{MainCommandExecutor};
\item how \cmdinline{IO Module} prints to screen.
\end{itemize}

\cmdinline{Shell} can be considered as the top-level class in the taskManager Logic. It applies the Fa\c cade pattern. It is aware of every other component in the Logic and hides the complexity of the Logic from classes outside.
%The shell also deals with the results passed from command executors. It
%calls IO module with the result as an argument. The shell also controls some
%miscellaneous operations like redo (), undo (), backup (), etc.

%% For example, if the command input is an ``add'' task operation, the Shell will receive a
%% command object with ``add'' operation and other details about the task. Then the shell
%% will call add command executor to carry out the detailed work. If the operation is
%% successfully carried out, a result object will be returned to the shell. The shell will then
%% call the IO module again with the result object to display the added task on the screen.
\item Parser

By intuition, \cmdinline{Parser} is a class that parse things -- \cmdinline{Command}s and \cmdinline{Result}s. It is used by instances of \cmdinline{IO Module} to do conversion from user input to \cmdinline{Command}s. That is, deduce the input text and return a \cmdinline{Command} object to the caller.
Why \cmdinline{IO Module} does not parse user input itself? It is because we want \cmdinline{IO Module}s to do their deeds only and do them well. Parsing user input is not the job of UI. The UI is only responsible for getting the user input and printing messages to screen. This is also an application of achieving high cohesion.

By the same argument, converting a \cmdinline{Result} object to text for output is doing by \cmdinline{Parser} as well.

\item Command Executors

\cmdinline{Command Executor}s is a collection of classes that directly manipulates underlying data structures, as its
name implies. \cmdinline{Command Executor} is an abstract class that is extended by \cmdinline{MainCommandExecutor} and \cmdinline{SubCommandExecutor}s such as \cmdinline{AddCommandExecutor}, \cmdinline{LsCommandExecutor}\footnotemark\ldots \ The relationship between command executors is demonstrated in the  class diagram in Figure 6.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.44]{main-sub-commandexecutors}
  \caption{MainCommandExecutor and SubCommandExecutors}
\end{figure}

\cmdinline{MainCommandExecutor} takes in a \cmdinline{Command} object, figures out the type of the command and distributes the work to corresponding \cmdinline{SubCommandExecutor}. which manipulates (be it add/set/get/remove items in) the underlying data structure and return a \cmdinline{Result} object accordingly.

\footnotetext{ Note that we only use \cmdinline{SubCommandExecutor} as a name to refer to these command executors, \cmdinline{SubCommandExecutor} is never in the code.}

For example, if the Command object passed to main command executor has ``ls'' as its
command field. The main command executor will infer this and invoke the
lsCommandExecutor object and asks it to do the actual work. lsCommandExecutor will
scan through all the tasks and then a result object containing all the tasks will be
returned.
\item Comparer

\cmdinline{Comparer} is implemented so as to compare different tasks according to deadline/priority/serial number\ldots
In fact sorting the tasks is made possible by \cmdinline{Comparer}. When a new comparer object is initialized, the keywords will be given to
the comparer as arguments. The comparer is then able to sort some given tasks residing
inside a task list according to the keywords (e.g. sort according to deadline, priority etc).

\begin{center}
  \lstset{
    caption=sorting a task list requires a Comparer.
    basicstyle=\ttfamily\footnotesize\bfseries,
    columns=flexible,
    linewidth=0.9\linewidth,
    abovecaptionskip=0.5em,
    frame=tb
  }
  \begin{lstlisting}
    vector<Task*> TaskList::sort(Comparer* comp) {};
  \end{lstlisting}
\end{center}

The code fragment above shows that sorting a task list objects requires a \cmdinline{Comparer} object.

\item Filters

\cmdinline{Filter} is an abstract class that is defined for selecting tasks that satisfy some condition from the main task list which stores all the tasks.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.44]{filter-classes}
  \caption{The Filter classes}
\end{figure}

It has subclasses like: 
The filter super class is basically an interface and the subclass filters are the filters that do the
actual work. For example, a GFilter uses a string as its keyword. It will filter out the tasks that
do not have this keyword as its group name.

\item Underlying Data Structures
\begin{enumerate}
\item Task

\cmdinline{Task} is the class that stores various information of one task.

One thing to note is the \cmdinline{clone()} function. It is designed for the
sake of security during development. It returns a copy of the \cmdinline{Task} object thus protects it from modification outside the class.

\item Task List

\cmdinline{TaskList} is a container of \cmdinline{Task} for the ease of manipulation.

The following diagram illustrates the structure of Task List class.
For the same reason above, a method \cmdinline{clone()} was implemented. All manipulations except for ``sort'' operation
are all done on duplications of the task list object passed in. We want to make sure that the task list is never screwed up by manipulations in other classes.
\end{enumerate}

\item Auto-completion Agent

Auto-completion function is only available in the TUI. The auto-completion agent is a knowledge-based agent.
Its knowledge base is initialized to all tokens in existing task descriptions and group names.
Tokens are automatically added when a word is typed (only in TUI) or when a tasks is added
or edited. When querying the agent with a string, the agent will answer with the
shortest suffix that forms a know token with that string. If no such suffix
exists, the agent will answer an empty string.

%The following diagram shows the details of the AutoCompletionAgent class.
%Figure . AutoCompletionAgent class
\end{enumerate}
\end{enumerate}

\subsection{A Typical Use Cases Explained in Sequence Diagrams}
Assume we are adding a task ``Write developer’s guide'' with deadline ``1d'':

\\The top level sequence diagram looks like:
\begin{center}
  \includegraphics[scale=0.7]{top-level-sequence-diagram}
\end{center}

A more detailed sequence diagram inside the Logic:
\begin{center}
  \includegraphics[scale=0.7]{sequence-diagram-inside-logic-part}
\end{center}

What happens inside the UI part:
\begin{center}
  \includegraphics[scale=0.75]{sequence-diagram-inside-UI-part}
\end{center}

\subsection{Testing}
In this section, we are going to present some bug reports produced during the development of
this project. In the later development cycles we did not choose to code an ATD as constrained by time and the complexity of
our project. However, we did have carried out systematic tests in order to discover bugs.

The following is a part of the bug reports we kept:

\vspace{0.15in}
\noindent \begin{tabular}{c | c | c}
  Bug Number & Description & Fixed by\\
1 & Most exception will still cause memory leak. & He Haocong\\
2 & Auto completion display bug. & He Haocong\\
3 & Debug assertion failed when trying to edit in TUI. & He Haocong\\
4 & Parser is adding extra spaces after \$0 replacement. & He Haocong\\
5 & possible accessing string index out of range in Parser. & He Haocong\\
6 & \multilineL{map bug: \$0 does not match arbitray number of tokens.} & Liu Jialong\\
7 & \multilineL{map bug: misbehavior of ``ls -g default'' after map ``ls'' ``ls -f yes''.} & Liu Jialong\\
\end{tabular}

\subsection{Possible Extensions}
Currently the product is a console application. Listed are some possible directions for extension
of this project.
\begin{enumerate}
\item User and Authentication controls

One possible feature that could be implemented is to make this program support multi-user
environment. In order to make sure the privacy of each user, it is better to include password
features.
\item GUI (Graphical User Interface) development

The current product has a command line based user interface together with a TUI.
Developers can make use of the core of this program to develop a graphical user interface. It
will possibly make this product more user-friendly and easier to use.
\item Windows notification application

Currently the product is able to help the user keep track of the tasks. Future improvement
could involve some alarm-like notifications. The project team has attempted to tackle this
feature. However, due to the limitation of time and knowledge, we are not able to integrate
this functionality into current v0.2 product.
\item Remote control

The current product is only working on independent terminals. In future extensions, it is
possible to extend this product to a network-support. Users are able to update their tasks
lists at any terminal with Internet access.
\end{enumerate}

\subsection{Miscellaneous}
\begin{enumerate}
\item util.cpp

util.cpp, as its name implies, provides utility functions for different classes.
These functions are not specifically related to certain classes thus we did not wrap it in a ``Util'' class as it increases
coupling of the software otherwise.

%% but are very useful in modifying data.
%% The functions are named in such a way that it clearly states what the
%% function does. So there is no need to have further explanations here.
%% \item TUI utilities

%% The implementation of the TUI is based on PDcurses (public domain curses). This tool is
%% free and downloadable. ``PDCurses is a public domain curses library for DOS, OS/2,
%% Win32, X11 and SDL, implementing most of the functions available in X/Open and
%% System V R4 curses. It supports many compilers for these platforms. The X11 port lets
%% you recompile existing text-mode curses programs to produce native X11 applications.
%% PDCurses is distributed mainly as source code, but some pre-compiled libraries are
%% available.'' (Quoted from: http://pdcurses.sourceforge.net/) The source files are available
%% for download at http://sourceforge.net/projects/pdcurses/files/
\end{enumerate}


\newpage
\section{Milestones and Individual Work}
\begin{enumerate}
\item Decide project topic and brainstorming.

Date: Sept 17 \\
Members attended: All
%\footnotetext{ Yes, we started the final project only after submitting CE2. In fact, the initial of the meeting is to polish CE2. :p}

We picked task manager as the project topic. There were conflicts among opinions as some of us do not like the GUI board game as it probably means development on Windows, while others want to have a taste of GUI programming. We finally came to agreement on the point that we were more confident to build a useful task manager that ourselves will use even after the project than a game that we are addicted to.

So we chose task manager.

We then came up with ``cool'' features like \cmdinline{import}, \cmdinline{export} and \cmdinline{cron} (set a regular task) and ended the meet before agreeing to meet tomorrow.

\item Design detailed architecture and develop prototype.

Date: Sept 18\\
Members attended: All

We designed the Shell--Parser--CommmandExecutor--TaskList architecture as we thought it was an intuitive design and easy to split up work.

We sat down together in a quiet lab and created the source files in to just print a welcome message, which is the very first (and rough) prototype. Then we added functions like adding, displaying, editting and removing tasks.

He Haocong was responsible for the \cmdinline{Shell}, which acted as a UI, and the \cmdinline{add} and \cmdinline{ls} command executors.\\
Liu Jialong was doing the parsing methods for the above commands.\\
%Wang Xiangyu did  \\
Zhou Biyan was taking down notes for the design --- including the architecture and class definitions.

All members participated equally.

\item Adding more commands to ``taskManager''.

Date: Sept 19\\
Members attended: All

We found nothing to do so we decided to meet again to further develop the prototype. This time we finished \cmdinline{import} and \cmdinline{export} commands. We decided to store the user's tasks in an XML file. Immediately we came to the problem of storing tasks with characters like \cmdinline{<}, \cmdinline{>} and \cmdinline{/}. We learnt from the way web browsers handles HTML -- store the special characters as ``entities''.

He Haocong coded command executors \cmdinline{edit} and \cmdinline{rm}.\\
Wang Xiangyu did the \cmdinline{import} command executor.\\
Zhou Biyan was responsible for the \cmdinline{export} command executor.\\
Liu Jialong was doing the parsing methods for the above commands. % \cmdinline{import} and \cmdinline{export} \cmdinline{edit} and \cmdinline{rm}.

\item Prepare for v0.1 demo

Date: Oct 7\\
Members attended: All

It was just a short meet before the demo for v0.1. We were there devising and rehersing a senario for demo and checking if there are any other bugs. 

\item After v0.1 demo\ldots

Date: Oct 9\\
Methods attended: All

We decided to:
\begin{enumerate}
\item  support \cmdinline{undo}, \cmdinline{redo}, \cmdinline{run}, TUI, command piping and mapping based on the feedback by the evaluators.
\item  give up \cmdinline{cron} considering the workload.
\end{enumerate}

Then the details of the implementation were discussed. The architecture was not changed.

Liu Jialong was allocated to code the prasing methods.\\
He Haocong was responsible for the TUI and \cmdinline{run}, \cmdinline{undo} and \cmdinline{redo} command executors.\\
Wang Xiangyu was asked to find out how notifications work on Windows.\\
%Zhou Biyan \ldots

\item Rearrange the code to compile on Windows (overnight session)

Date: Oct 18 - 19\\
Members attended: He Haocong, Liu Jialong

The purpose of this session is to extract the method declaration to .h and definition to .cpp files to make the code standard.

As we were developing on *nix, we realized that squeezing all the classes in the .h files will fail to compile on Windows using Visual Stdio. After reconstrcuting the codes, we are able to compile taskManager on Windows and write a better Makefile by the way -- the previous Makefile contains only one rule and one command, which is something like \cmd{g++ -o taskManager main.cpp Shell.h Parser.h MainCommandExecutor.h \nolinebreak \ldots}
We got to know better of C++ compilation process by writing the new Makefile and solving the linking problems and it was worth the stay-up.

\item Feature close shop, testing and documenting. (overnight session)

Date: Nov 4 - 5\\
Members attended: He Haocong, Liu Jialong

Things done:
\begin{enumerate}
\item Memory leak was fixed.
\item User guide was compiled.
\item We went throught the user guide to make sure the commands work.
\item The taskManager startup script (\cmdinline{tmrc}) was enriched to provide some more natural commands.
\end{enumerate}

\item Finish the last requirements for submission.

Date: Nov 6\\
Members attended: All

We met up to:
\begin{enumerate}
\item compile the developer guide
\item usability testing
\item brainstorming for demo video
\end{enumerate}

\item Finish the last requirements for submission.

Date: Nov 8\\
Members attended: He Haocong, Liu Jialong, Zhou Biyan

Fine tuning the software and proj manual.
Do video.
\end{document}
