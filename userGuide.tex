\documentclass[12pt, a4paper]{article}
\usepackage{indentfirst}
%\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{/home/jialongl/Documents/sem3/se/proposal/}{/home/jialongl/Documents/sem3/se/finalprojScreenshots/}}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    urlcolor=blue
}

\usepackage{fullpage}

%\oddsidemargin 0.3in
%\topmargin -0.3in
%\textheight 8.0in
%\usepackage{setspace}
%\onehalfspacing

%\usepackage{palatino}
%\usepackage{avant}

\newcommand{\cmd}[1]{{\bf \texttt{\begin{quote} #1 \end{quote}}}}
\newcommand{\cmdinline}[1]{{\bf \texttt{#1}}}

\begin{document}
\begin{titlepage}
  \centering

  \textsc{\LARGE cs2103 project manual}
  \\[1.5cm]
  \hrule
  \\[0.5cm]
  \Large \bfseries Command line task manager
  \\[0.4cm]
  \hrule
  \\[1.4cm]

\includegraphics[scale=0.73]{on_cover_page}
\\[1.1cm]
  \begin{tabular}{c | c | c | c}
    \includegraphics[scale=0.72]{U099121H}&
    \includegraphics[scale=0.72]{U099122U}&
    \includegraphics[scale=0.72]{U099120W}&
    \includegraphics[scale=0.72]{U094837M}\\

    \small{He Haocong} & \small{Liu Jialong} & \small{Wang Xiangyu} & \small{Zhou Biyan}\\
    \small{\texttt{U099121H}} & \small{\texttt{U099122U}} & \small{\texttt{U099120W}} & \small{\texttt{U094837M}}\\
  \end{tabular}

  \vfill
  {\large \today}
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}
This is the manual for a command-line utility (referred to as taskManager) that manages one's to-do's.

\newpage
\section{User Guide}
\subsection{Quick Start}

This section introduces you the minimum amount of commands to get started.

\begin{enumerate}
\item Start taskManager shell:

On Mac OS and GNU Linux (referred to as ``*nix'' later), taskManager can be started from shell by commands: \cmd{\$ cd the/folder/containing/taskManager\\ \$ ./taskManager\footnotemark}

On Microsoft Windows, taskManager can be launched in command prompt as well, or simply by double clicking ``taskManager.exe''.

Once taskManager is launched, you will see a prompt like \cmdinline{"\textgreater\_"}, and you will start typing commands!

\footnotetext{ *nix version can be run at any directory after installing taskManager -- \cmdinline{"make install"}. See details in section \cmdinline{"Compilation and Installation".}}

\item Add some tasks:\cmd{\$ ./taskManager\\
  > \  add "Sample task 1"\\
  > \  add "Sample task 2"\\
  TaskManager: This task is highly similiar to some existing task, do you really want to add it? \textcolor{blue}{y}}
To add a task, simply use \texttt{add} command followed by the description of the task in a pair of quotation marks.

\emph{If no error messages are shown, the task is successfully added.}
TaskManager may prompt for confirmation if the task to be added is highly similar to some existing task(s) to help prevent people forget adding tasks, which is the case in the example above.

\item List the existing tasks: 
\cmd{\begin{tabbing}
    > \ ls\\
    1 \hspace{0.3in} \= Sample task 1\\
    2 \>Sample task 2
  \end{tabbing}
}
To see the existing tasks, use \cmdinline{ls} command. By default, the taskManager shows the serial numbers and the descriptions of the tasks.

\item Mark a task as finished:
\cmd{
  \begin{tabbing}
    > \ finish 2\\
    > \ ls\\
    1   \hspace{0.3in} \=Sample task 1\\
    2 f \>Sample task 2
  \end{tabbing}
}
To finish an existing task, use \cmdinline{finish} command followed by the serial number of the task to finish. 
Notice that for finished task, an `f' is shown between serial number and task description.

\item Remove task(s): \cmd{\begin{tabbing}
    > \ ls\\
    1 \hspace{0.3in} \= Sample task 1\\
    2 f \>Sample task 2\\
    > \ rm 1\\
    TaskManager: Do you really want to remove this task permanently? \textcolor{blue}{y}\\
    > \ ls\\
    2 f \>Sample task 2
  \end{tabbing}
}

To remove an existing task, use \cmdinline{rm} command followed by the serial number of the task to remove. TaskManager will prompt for confirmation when removing tasks.

\item Exit from taskManager:
\cmd{> \ exit}

To quit from taskManager, use \cmdinline{exit} command. 
All changes to the existing tasks will be automatically saved.
\end{enumerate}

\subsection{More commands}
\subsubsection{read, import and export}

TaskManager stores the tasks in an XML file which is by default \cmdinline{\~{}/record.xml} on *nix, and \cmdinline{\%USERPROFILE\%\textbackslash record.xml} on Windows.

TaskManager also supports importing/exporting the existing tasks from/to XML and HTML files. This is done by \cmdinline{read}, \cmdinline{import} and \cmdinline{export} commands.

\begin{enumerate}
\item [ \cmdinline{read} ] reads an XML file, list all the tasks it contains without affecting the current task list.

This is helpful when you only want to peek the content of an xml file without really importing it.
\cmd{
\begin{tabbing}
  > \ ls\\
    1 \hspace{0.3in}\=  Sample task 2\\
    > \ read midterms.xml\footnotemark \\
    1 f \>CS2103 midTerm Sep 29 06:30 - 07:30 pm MPSH 1B\\
    2 f \>CS3230 midTerm Oct 15 06:00 pm\\
    3 f \>CS3241 midTerm Oct 07 lecture\\
    4 f \>CS3244 midTerm Oct 04 lecture\\
    5 f \>ST2132 midTerm Oct 08 LT33 12:15 - 1:30 pm\\
    > \ ls\\
    1 \>Sample task 2
\end{tabbing}
}

\footnotetext{ The file name is not quoted. If the file name contains space, please quote it with a pair of quotation marks.}

\item [ \cmdinline{import} ] is similar to \cmdinline{read} command. It reads the content of the XML file and appends all the tasks in it to current task list.
\cmd{
\begin{tabbing}
  > \ ls\\
    1  \hspace{0.3in}\=Sample task 2\\
    > \ import mytasks.xml\\
    1 \>Sample task 2 \footnotemark\\
    2 f \>CS2103 midTerm Sep 29 06:30 - 07:30 pm MPSH 1B\\
    3 f \>CS3230 midTerm Oct 15 06:00 pm\\
    4 f \>CS3241 midTerm Oct 07 lecture\\
    5 f \>CS3244 midTerm Oct 04 lecture\\
    6 f \>ST2132 midTerm Oct 08 LT33 12:15 - 1:30 pm
\end{tabbing}
}

\footnotetext{ Task 1 is still in task list. Importing tasks will not erase existing tasks.}

\item [ \cmdinline{export} ] exports the current task list to an XML or HTML file.
\cmd{
  \begin{tabbing}
    > \ export sampletasks.xml\footnotemark\\
    > \ \=exit\\
    \$ \>cat sampletasks.xml\\
    \>\+<taskList>\\
    <task>\\
    <serialNumber> 1 </serialNumber>\\
    <deadline> 1288473083 </deadline>\\
    <priority> 0 </priority>\\
    <description> Sample task 2 </description>\\
    <group> default </group>\\
    <isFinished> 0 </isFinished>\\
    </task>\\
    </taskList>
  \end{tabbing}
}

\footnotetext{ Currently \cmdinline{export} does not support environmental variables in path. i.e. \cmdinline{export \~{}/abc.xml} will not export the file to user's home directory \cmdinline{/home/username/}.}
 
\cmdinline{export} can also be used to generate an HTML file which is more visually pleasant in your favourate browser.
\cmd{> \ export -html sampletasks.html\footnotemark\\
  > \ exit}
\footnotetext{ If the name of the HTML file to export is not specified, the default file name \cmdinline{"record.html"} is used.}

\newpage
\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.73, viewport=80 0 600 380]{exporthtml}
  \caption{tasks exported as webpage \footnotemark}
\end{figure}
\end{enumerate}
\footnotetext{ Page may not render correctly in IE 6 or its earlier versions.}

\subsubsection{task}
\noindent \cmd{
  \begin{tabbing}
    > \=task 1 \+\\
    Number: \ \= 1  \ \ \= Deadline: \=Sun Oct 31 05:11:23 2010\\
    Priority:\>0 \> Status:\>Doing\\
    Group:\> default\\
    Details:\\
    \ \ Sample task 2 \footnotemark
  \end{tabbing}
}
\footnotetext{ Adding tasks with detailed information is covered in section 2.3.1. In this example, default values are shown.}
To show detail information of a task, use \cmdinline{task} command followed by serial number of the task.

\subsubsection{pri}
\noindent \cmd{
  \begin{tabbing}
    > \  pri 1 10\\
    > \ \=task 1 \+\\
    Number: \ \= 1 \ \ \= Deadline: \= Sun Oct 31 05:11:23 2010\\
    Priority:\>10 \> Status:\>Doing\\
    Group: \> default\\
    Details:\\
    \ \ Sample task 2
  \end{tabbing}
}

To change the priority of a task, use \cmdinline{pri} command followed by the serial number of a task and its new priority.
Priority is typically a number between -20 and 20. By default, the priority of a newly added task is 0.

\subsubsection{edit}
\noindent \cmd{
  \begin{tabbing}
    > \ edit 1 -d "Sample task 3" -p 12 -t 1d\footnotemark \ -g SampleGroup -f yes\\
    > \ \=task 1 \+\\
     Number: \ \= 1 \ \ \= Deadline: \=Mon Nov  1 05:47:59 2010\\
     Priority:\>12 \> Status:\>Finished\\
     Group: \> SampleGroup\\
     Details:\\
     \ \ Sample task 3
  \end{tabbing}
}

To edit a task, \cmdinline{edit} command which has the form: \cmdinline{edit taskSerialNumber -d newDescription -p newPriority -t newDeadline -g newGroup -f finished\_or\_not}. Only \cmdinline{taskSerialNumber} is compulsory. Besides, to finish a task, \cmdinline{finish 1} is equivalent to \cmdinline{edit 1 -f yes}.

\footnotetext{ -t 1d means setting the deadline to be 1 day later. Time formats that taskManager accept are discussed in section 2.3.1.}

\subsubsection{undo and redo}
\noindent \cmd{> \ undo}
would undo the last command. Note that it has no effect on commands like \cmdinline{ls}, \cmdinline{export}, \cmdinline{tui} and \cmdinline{undo}.
\cmd{> \ redo}
re-does the last undo. It can be executed util all the undo's are re-done.

\subsection{Using Options}

Like \cmdinline{edit}, some of the commands come with options to support more functionality.
In this section they are introduced in great detail.

%\cmdinline{export} not support the task-selective options \cmdinline{-g -k -f}.
%Executing these commands on a selected task set can be done with command piping, which is discussed in section 2.5.1.

\subsubsection{add}
\cmdinline{add} has three flags: \cmdinline{-t} to specify deadline, \cmdinline{-p} to set priority and \cmdinline{-g} to put the group name for a task.
\begin{enumerate}
\item [ \cmdinline{-t} ] adds a task with a deadline: \cmd{> \ add "74 hours from now" -t 3d2h\\
  > \ add "Tomorrow 2359" -t b2d\\
  > \ add "due at Jan 2, 1970 00:00 UTC" -t 86400
}
TaskManager support 3 types of time format:

\begin{enumerate}
\item[ \cmdinline{"plus" format} ]
  ``Plus'' format specifies the how much time left for the task, and it has form \cmdinline{?w?d?h?m}\footnotemark, where each question mark stands for a number (not a digit).\\
  For example, 3d2h means the task will due after 3 days 2 hours the moment the command is executed -- you have 3 days and 2 hours to finish it.

\footnotetext{ At least one of letters w/d/h/m should be specified.}

\item[ \cmdinline{"by" format} ]
  ``By'' format has a similar form of ``plus'' format. It is in the form of \cmdinline{b?w?d?h?m}\footnotemark, where each question mark stands for a number (not a digit). For example:
\footnotetext{ At least one of letters w/d/h/m should be specified.}

\begin{tabular}{ r | l }
  \cmdinline{b0d22h} & by 10:00pm today.\\
  \cmdinline{b2d} & by 23:59 tomorrow.\\
  \cmdinline{b1w} & by the end of this week. i.e. 23:59 of the Saturday\footnotemark of this week. \\
  \cmdinline{b0w5d} & by 23:59 on Friday of this week.\\
  \cmdinline{b2w3d8h} & by 8:00am on the Wednesday of the next next week.\\
\end{tabular}

\footnotetext{ Sunday is the first day of a week.}

\item[ \cmdinline{Unix timestamp} ]
``Unix timestamp'' means the number of seconds elapsed since Jan 1, 1970 00:00:00. It is not recommended for users, but rather used as a lower-order procedure for developers.
\end{enumerate}

\item[ \cmdinline{-p} ] adds a task with a priority: \cmd{> \ add "some important task" -p 20}
\item[ \cmdinline{-g} ] specifies a group for a task: \cmd{> \ add "the task with group"\footnotemark \  -g SampleGroup}
\end{enumerate}

\footnotetext{ If group name contains spaces, use a pair of quotation marks to quote it.}

\emph{Options are not compulsory. Different options can be used together.} For example: \cmd{> \ add "CS2103 final exam" -p 10 -g "finals" -t b3w2d} would add a task ``CS2103 final exam'' which has a priority of 10, belongs to group ``finals'' and is held on the Tuesday 3 weeks from now.

\subsubsection{ls}
\cmdinline{ls} has four flags: \cmdinline{-s} to sort tasks, \cmdinline{-k} to search tasks, \cmdinline{-f} to view only (un)finished tasks and \cmdinline{-g} to filter tasks by group name.
\begin{enumerate}
\item[ \cmdinline{-s} ] sorts the existing tasks: \cmd{> \ ls -s "deadline priority"}

A more general format is: \cmdinline{ls -s "keyword1 keyword2" \ldots}

The listed tasks will be sorted by keyword1 and then keyword2 \ldots
    
Available columns are: deadline, priority and serialnumber. Prefix of a keyword is also acceptable. e.g. \cmdinline{ls -s "p"} will sort the tasks by their priorities.

Examples: \cmd{
\begin{tabbing}
  > \ ls -s "p d" \+\\
  1 \hspace{0.3in}\= task 1 highest priorty. \ \=  3  Sun Oct 31 06:49:09 2010\\
  2 \> task 2 high priority. \> 2  Mon Nov  1 06:54:42 2010\\
  3 \> task 3 default priority. \> 0   Tue Nov  2 06:54:37 2010
\end{tabbing}
}
\item [ \cmdinline{-k} ] filters tasks with a keyword\footnotemark \ where \cmdinline{?} means any single character, \cmdinline{*} means a string of any length (including 0 length).
\footnotetext{ keyword is case insensitive.}

Take command \cmdinline{ls -k *Sam?le*task} as an example, \cmdinline{"This is a sample with an important task"} will match \cmdinline{*Sam?le*task} as the first \cmdinline{*} matches \cmdinline{"This is a "}, \cmdinline{?} matches \cmdinline{`p'} and the second \cmdinline{*} matches \cmdinline{" with an important "}.

\cmdinline{"samqleTask"} will also match \cmdinline{*sam?le*task} as both \cmdinline{*} maps empty string and \cmdinline{?} to be \cmdinline{`q'}.

\item[ \cmdinline{-f} ] shows finished/unfinished tasks:

  \cmdinline{ls -f yes} shows only finished tasks.\\
  \cmdinline{ls -f no} shows only unfinished tasks.

\item[ \cmdinline{-g} ] shows tasks of a specific group: \cmdinline{ls -g SampleTask} makes tasks only from SampleTask group shown.
\end{enumerate}

{\bf  \textcolor{red}{Important}}:
\begin{quote}
As said, different options can be used together when issuing commands.
When more then one restrictive options are present, \emph{conjuction} of these restrictions are used. e.g. \cmd{ls -g SampleTask -f y} will show tasks that are finished AND from ``SampleTask'' group. 
\end{quote}

\subsubsection{rm}
\cmdinline{rm} has basically two usages: remove tasks by a group name or serial number.

Use \cmdinline{-g} option to remove a group of tasks: \cmdinline{rm -g SampleTask} removes the entire SampleTask group.

\cmdinline{rm} can be used remove several tasks once as well. e.g. \cmdinline{rm 1 2 3} removes tasks 1, 2 and 3.

%% \subsubsection{edit}
%% This is discussed in section 2.2.4.

%% \subsubsection{export}
%% This is discussed in section 2.2.1.


\subsection{Getting inTUItive -- The Text User Interface}
The text-based user interface (referred to as TUI later) makes interaction more intuitive by visualizing the deadlines, groups and simplifying manipulation from issuing commands to moving cursors and pressing keys.

\\TUI can be launched using command \cmdinline{tui} in command-line mode:

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.73]{tui-launched-mac}
  \caption{The first screen of TUI}
\end{figure}

As seen, the tasks are grouped according to deadlines. If a task's deadline is ``Anytime'', it means the task has no specific deadline -- you can finish it at ease.

Besides, TUI provides some features that are not available in the command line mode:\begin{enumerate}
\item auto-completion
  using \cmdinline{TAB} key.

\item summary of tasks in a calendar
  a small calendar at the bottom right corner with the dates that has tasks due highlighted

\item incremental search
  of tasks by keyword.
\end{enumerate}
This is a summary of the key bindings:\\

\begin{tabular}{c | c}
  \cmdinline{SPACE} or \cmdinline{ENTER} & show details of the selected task\\
  \cmdinline{$\downarrow$} or \cmdinline{j} & select the task below\\
  \cmdinline{$\uparrow$} or \cmdinline{k} & select the task above\\
  \cmdinline{g} & select the first task \\
  \cmdinline{G} & select the last task \\
  \cmdinline{number selectionKey}\footnotemark & select \cmdinline{number} tasks above/below\\
  \cmdinline{p} & previous page/page up\\
  \cmdinline{n} & next page/page down\\
  \cmdinline{u} & undo\\
  \cmdinline{R} & redo\\
  \cmdinline{c} & show the small calendar\\
  \cmdinline{C} & issue a command without leaving TUI\\
  \cmdinline{a} & add a task\\
  \cmdinline{e} & edit a task\\
  \cmdinline{d} & remove a task\\
  \cmdinline{f} & finish a task\\
  \cmdinline{s} & search tasks by keywords\\
\end{tabular}
\footnotetext{ It means pressing a number key and then press $\uparrow$/$\downarrow$/\cmdinline{j}/\cmdinline{k} key.}

You can always press \cmdinline{H} to read the key bindings.

\subsection{Advanced Usages}
\subsubsection{command piping}
\noindent \cmd{> \ ls \textbar \  rm}
TaskManager supports command piping for most commands though it is a bit different from traditional Unix pipe.
Piping means if one command selects some tasks, then the selected tasks will be passed to the next command as input. The tasks after the last command will be shown as output.
Piping in taskManager is done with symbol \cmdinline{\textbar}. When a pipe signs appear in a command, the broken-up commands (separated by pipes) are executed one by one from left to right. For example:

\begin{enumerate}
\item finish all tasks:  \cmd{> \ ls \textbar \  finish}
\item remove all finished tasks:  \cmd{> \ ls -f yes \textbar \  rm}
\item import from a file and replace current task list:  \cmd{> \ ls \textbar \  rm \textbar \  import newTasks.xml}
\item import all CS2103 group tasks from a file:  \cmd{> \ read newTasks.xml \textbar \  ls -g CS2103 \textbar \  add}
\item export all CS2103 related tasks to a html file: \cmd{> \ ls -k *CS2103* \textbar \  export -html cs2103tasks.html}
\item show details of CS2103 tasks, sort by priority: \cmd{> \ ls -g CS2103 \textbar \  sort "pri" \textbar \  task}
\end{enumerate}

\subsubsection{command mapping}
\noindent \cmd{> \ map "ls" "ls -f no"}
TaskManager supports custom command mapping/aliasing so you can alias the taskManager commands to the format you are more comfortable with.

General format of \cmdinline{map} is: \cmdinline{map "new command" "original command"}

A simple mapping is like the previous example, which maps \cmdinline{ls} to \cmdinline{ls -f no}, which effectively hides finished tasks when doing \cmdinline{ls}.
To retain the original \cmdinline{ls} command, use \cmdinline{\ls}. The command that \cmdinline{ls} maps to will not be executed then.

When several \cmdinline{map} commands are executed in sequence : \cmd{> \ map "lsa" "ls"\\
  > \ map "ls" "ls -f no"}
Then \cmdinline{ls} will show the unfinished tasks only, while \cmdinline{lsa} lists all the tasks.

The order of mapping matters as commands are executed one by one. Thus reversing the order of \cmdinline{map} commands MIGHT NOT work.

More complex mapping makes use of symbol \cmdinline{\$}. There are two kinds of \cmdinline{\$} symbols:
\begin{quote}
\cmdinline{\$0} matches all characters from the current position.\\
\cmdinline{\$1}, \cmdinline{\$2}, \cmdinline{\$3} \ldots matches one token (i.e. a word or several words .
\end{quote} Examples:
\begin{enumerate}
\item \cmd{> \ map "tomorrow \$1" "add \$1 -t 1d"\\
  > \ tomorrow "Finish user guide"}    
The latter command will be parsed as \cmdinline{add "Finish user guide" -t 1d}, and a new task ``Finish user guide'' will be added with the deadline of 24 hours.

\item \cmd{> \ map "do \$1 at \$2" "add \$1 -t \$2"\\
  > \ do "Laundry" at 4h}
The latter command will be parsed as \cmdinline{add "Laundry" -t 4h}, and a new task called ``Laundry'' will be added with the deadline of 4hours.

\item \cmd{> \ map "ls \$0" "ls -f no \$0"
  > \ ls
  > \ ls -g cs2103}
The second command will be parsed as \cmdinline{ls -f no}, and will list out all unfinished tasks.
The third command will be parsed as \cmdinline{ls -f no -g cs2103}, and will list out all unfinished cs2103 tasks.
\end{enumerate}

{\bf \textcolor{red}{Important:}}
%\begin{quote}
TUI uses \cmdinline{ls} to retrieve tasks. Mapping \cmdinline{ls} to something else will affect behaviour of TUI, which may or may not be the case you want.
%\end{quote}

\subsubsection{taskManager script}

Task manager commands can be saved in a text file and be executed using run command. \cmd{
\begin{tabbing}
  \$ cat tmscript\\
  ls\\
  map "ls" "ls -f no"\\
  ls\\
  \$ ./taskManager\\
  Task Manager V 0.2\\
  type " exit" to quit, "help" for more instructions\\
  ==================================================\\
  > \ run tmscript\\
  1 f \hspace{0.16in}\=Sample task 1. This also has high priorty\\
  2 \> Sample task 2. This has high priority\\
  3 \> Sample task 3. This is the latest\\
  \\2 \> Sample task 2. This has high priority\\
  3 \> Sample task 3. This is the latest
\end{tabbing}
}

The first 3 tasks are the result of the first \cmdinline{ls} in the script. The last 2 tasks are the result of the second \cmdinline{ls} in the script. Because \cmdinline{ls} is mapped to \cmdinline{ls -f no}, finished tasks are not shown by the second \cmdinline{ls}.

% TaskManager scripts are plain text files. ".txt" suffix is omitted here. In windows, suffix is hidden by default. To show it, check corresponding checkbox under Tools -> \ Folder Options in a file browser. Windows may not know how to open file with no suffix.

\subsubsection{startup script}

By default, taskManager executes a special script everytime when it is started. 
This script is \cmdinline{\~{}/.tmrc} on *nix and \cmdinline{\%USERPROFILE\%\textbackslash tmrc.txt} on Windows.
This file can be editted to include customized settings.\\

Examples:
\begin{enumerate}
\item To switch to the interactive user interface by default, add this line into tmrc: \cmd{tui}
\item To save a backup file when taskManager is started: \cmd{export /tmp/backupTasklist.xml}
\item To show tasks when taskManager is started: \cmd{ls}
\item To remove finished tasks when taskManager is started: \cmd{ls -f yes \textbar \  rm}
\item To run a script with all self-defined mappings when taskManager is started:  \cmd{run /home/myusername/mymappings}
\end{enumerate}

\subsubsection{talk to taskManager}

For all inputs that cannot be recognized by taskManager as a command, it will be treated as natural language sentense. 
TaskManager will try its best to recognize it and give correct response. For example: \cmd{> \ what do I do today?} will list all the tasks due today.

\subsection{Compilation and Installation}
This section discusses compilation and installation of taskManager.
One thing to note is that the TUI is build by default, which requires PDcurses library.
It is free and can be downloaded here:
\url{http://sourceforge.net/projects/pdcurses/files/}.

Unix-like Operating Systems are likely to have curses (its cross-platform version is PDcurses) library installed already.
For Windows' users convenience, the necessary library files for compilation are included in the zip.

\subsubsection{Microsoft Windows}
On Windows, taskManager can be built with Visual Studio 2008\textsuperscript{\textregistered} \footnotemark \ in the following steps:

\begin{enumerate}
\item Start Visual Studio with ``C++ Development Settings''.
\item Create an \emph{empty win32 console project} called ``taskManager''.
\item Drag all the .h and .cpp files (including those in the subdirectories) into the solution folder. Files should be automatically categorized into header files and source files.
\item Press \cmdinline{Alt + F7} to edit the project properties. Under \cmdinline{"Configuration Properties" => "General"}, set \cmdinline{"Character Set"} to be \cmdinline{"Use Multi-Byte Character Set"}; Under \cmdinline{"Linker" => "Input"}, add pdcurses.lib to \cmdinline{"Additional Dependencies"} and add the folder containing pdcurses.lib to \cmdinline{"Additional Library Directories"}.
\item Copy pdcurses.dll to \cmdinline{\%WINDIR\%\textbackslash system32\textbackslash} or the directory your executable will be generated (which would be the ``Debug'' folder).
\item Build the solution.
\item Copy the \cmdinline{tmrc} to your home directory (e.g. \cmdinline{C:\textbackslash Documents and Settings\textbackslash John Doe\textbackslash} on Windows XP) and rename it to \cmdinline{tmrc.txt} in order to use the commands we pre-customized. This step is optional.
\end{enumerate}

\footnotetext{ Menu names mentioned below may vary among different versions of Visual Studio.}

\subsubsection{Unix-like Operating Systems}

On Unix-like operating systems such as GNU Linux and Mac OS X: start a shell; unzip the zip archive; change directory properly and type: \cmd{\$ make\\
  \$ sudo make install}

``make install'' is optional. It just makes taskManager available system wide by copying the executable and man page to cooresponding directories.

Another option is to copy the \cmdinline{tmrc} to your home directory and rename it to \cmdinline{.tmrc} in order to use the commands we pre-customized.

The curses library should ship with most Linux distributions and Mac OS. If not, it can be installed with the package manager (\cmdinline{apt-get}, \cmdinline{yum}, \cmdinline{pacman} on various Linux distributions and \cmdinline{port} on Mac).

\newpage
\section{Developer Guide}


\newpage
\section{Milestones and Individual Work}
\begin{enumerate}
\item Decide project topic and brainstorming.

Date: Sept 17 \footnotemark\\
Members attended: All
\footnotetext{ Yes, we started the final project only after submitting CE2. In fact, the initial of the meeting is to polish CE2. :p}

We picked task manager as the project topic. There were conflicts among opinions as some of us do not like the GUI board game as it probably means development on Windows, while others want to have a taste of GUI programming. We finally came to agreement on the point that we were more confident to build a useful task manager that ourselves will use even after the project than a game that we are addicted to.

So we chose task manager.

We then came up with ``cool'' features like \cmdinline{import}, \cmdinline{export} and \cmdinline{cron} (set a regular task) and ended the meet before agreeing to meet tomorrow.

\item Design detailed architecture and develop prototype.

Date: Sept 18\\
Members attended: All

We designed the Shell--Parser--CommmandExecutor--TaskList architecture as we thought it was an intuitive design and easy to split up work.

We sat down together in a quiet lab and created the source files in to just print a welcome message, which is the very first (and rough) prototype. Then we added functions like adding, displaying, editting and removing tasks.

He Haocong was responsible for the command executors of \cmdinline{add} and \cmdinline{ls}.\\
Liu Jialong was doing the parsing methods for the above commands.\\
Wang Xiangyu did \\
Zhou Biyan was coding for 

All members participated equally.

\item Adding more commands to ``taskManager''.

Date: Sept 19\\
Members attended: All

We found nothing to do so we decided to meet again to further develop the prototype. This time we finished \cmdinline{import} and \cmdinline{export} commands. We decided to store the user's tasks in an XML file. Immediately we came to the problem of storing tasks with characters like \cmdinline{<}, \cmdinline{>} and \cmdinline{/}. We learnt from the way web browsers handles HTML -- store the special characters as \emph{``entities''}.

He Haocong coded command executors \cmdinline{edit} and \cmdinline{rm}.\\
Wang Xiangyu did the \cmdinline{import} command executor.\\
Zhou Biyan was responsible for the \cmdinline{export} command executor.\\
Liu Jialong was doing the parsing methods for \cmdinline{import} and \cmdinline{export}.

\item Integrate v0.1

  Date: Oct 7\\
  Members attended:

\item After v0.1 demo\ldots

  Date: Oct 9\\
  Methods attended: All


\item Refractor the code base for Windows Compilation (overnight session)

Date: Oct 22 - 23\\
Members attended: He Haocong, Liu Jialong

The purpose of this session is to extract the method declaration to .h and definition to .cpp files to make the code standard.

As we were developing on *nix, we realized that squeezing all the classes in the .h files will fail to compile on Windows using Visual Stdio. After refractoring, we are able to compile taskManager on Windows and write a better Makefile by the way -- the previous Makefile contains only one rule and one command, which is something like \cmd{g++ -o taskManager main.cpp Shell.h Parser.h MainCommandExecutor.h \nolinebreak \ldots}
We got to know better of C++ compilation process by writing the new Makefile and solving the linking problems and it was worth the stay-up.

\item At media lab \ldots

Date: Oct 29\\
Members attended: All

\item Feature close shop, testing and documenting. (overnight session)

Date: Nov 4 - 5\\
Members attended: He Haocong, Liu Jialong

\item Polishing the last bits for submission.

Date: Nov 6\\
Members attended: All

We met up to do the developer guide, compilation on Windows, usability testing and video.
\end{enumerate}

\end{document}
